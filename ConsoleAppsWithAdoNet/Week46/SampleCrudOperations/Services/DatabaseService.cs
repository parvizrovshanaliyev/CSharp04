using System.Data.SqlClient;
using SampleCrudOperations.Models;

namespace SampleCrudOperations.Services
{

    /*
     * =====================================================================================================
     *  DatabaseService (Synchronous ADO.NET)
     *  -----------------------------------------------------------------------------------------------------
     *  PURPOSE
     *  -------
     *  This class isolates ALL database access for the Customers table. The rest of the application should
     *  never need to new-up SqlConnection/SqlCommand directly. That keeps responsibilities clear and makes
     *  it easier to evolve data access later (e.g., add transactions, logging, retries).
     *
     *  KEY PRACTICES USED HERE
     *  -----------------------
     *  • Synchronous ADO.NET calls (ExecuteNonQuery / ExecuteScalar / ExecuteReader).
     *  • Parameterized SQL for every user value (prevents SQL injection + improves plan caching).
     *  • Explicit SqlDbType and, where appropriate, Size to match schema (avoids implicit conversions).
     *  • "using" statements to guarantee disposal even on exceptions (connections, commands, readers).
     *  • Centralized command timeout and parameter binding helper for consistency.
     *
     *  TABLE SCHEMA (REFERENCE)
     *  ------------------------
     *      CREATE TABLE dbo.Customers
     *      (
     *          Id        INT IDENTITY(1,1) PRIMARY KEY,
     *          Name      NVARCHAR(100) NOT NULL,
     *          Email     NVARCHAR(200) NOT NULL,
     *          CreatedAt DATETIME2(0)  NOT NULL DEFAULT SYSDATETIME()
     *      );
     *
     *  NOTES
     *  -----
     *  • Date/Time: For global systems, prefer UTC (DateTime.UtcNow). Here, DateTime.Now is used for simplicity.
     *  • Errors: This class lets SqlException and others bubble up. Callers (the console UI) catch and show messages.
     *  • Concurrency: Simple "last write wins". For optimistic concurrency, add a RowVersion column and include it
     *    in WHERE conditions for updates/deletes.
     * =====================================================================================================
     */


    /// <summary>
    /// Handles all database operations for the Customer table
    /// Implements CRUD operations using ADO.NET and async/await pattern
    /// </summary>
    public class DatabaseService
    {
        /*
         * Connection string is stored as a private readonly field
         * This ensures it can't be modified after initialization
         * and is only accessible within this class
         */
        private readonly string _connectionString;

        public DatabaseService(string connectionString)
        {
            _connectionString = connectionString;
        }

        /*
 * CreateCustomer
 * ===============
 * Purpose:
 * ---------
 * Inserts a new customer record into the database and returns the newly generated
 * identity (ID) value.
 * 
 * Process:
 * --------
 * 1. Creates a new database connection object.
 * 2. Opens the connection synchronously.
 * 3. Prepares an SQL INSERT statement using parameterized values to prevent SQL injection.
 * 4. Executes the command synchronously using ExecuteScalar().
 * 5. Retrieves and returns the newly generated ID value for the inserted row.
 * 
 * Returns:
 * --------
 * int — The ID of the newly created customer record in the database.
 * 
 * Notes:
 * ------
 * • SCOPE_IDENTITY() is used to retrieve the ID generated by this session and scope.
 *   It is safer than @@IDENTITY, which may return IDs from triggers in other tables.
 * • All parameters are explicitly bound using SqlParameter objects or AddWithValue() to
 *   ensure data type safety and to protect against SQL injection attacks.
 * • Using “using” statements guarantees disposal of connection and command objects even
 *   if exceptions occur.
 */
        public int CreateCustomer(Customer customer)
        {
            // 1. Create a new SQL connection using the configured connection string.
            using var connection = new SqlConnection(_connectionString);

            // 2. Open the connection synchronously.
            //    Opening a connection establishes a physical link to the SQL Server.
            connection.Open();

            // 3. Define the SQL statement for inserting a record.
            //    SCOPE_IDENTITY() ensures that the ID returned is the one generated
            //    in this same scope (current session + current insert).
            const string sql = @"
        INSERT INTO Customers (Name, Email, CreatedAt) 
        VALUES (@Name, @Email, @CreatedAt);
        SELECT SCOPE_IDENTITY();
    ";

            // 4. Create a SQL command object using the SQL statement and connection.
            using var command = new SqlCommand(sql, connection);

            /*
             * Parameter Usage and Purpose:
             * =============================
             * Parameters are used to safely pass data to the SQL query.
             * This avoids string concatenation, which can cause SQL injection vulnerabilities.
             * 
             * 1. @Name — NVARCHAR(100)
             *    • Stores customer’s name.
             *    • Supports Unicode characters.
             * 
             * 2. @Email — NVARCHAR(200)
             *    • Stores customer’s email address.
             *    • Allows typical special characters such as '@' and '.'.
             * 
             * 3. @CreatedAt — DATETIME2
             *    • Captures the exact timestamp of record creation.
             *    • DATETIME2 provides more precision than DATETIME.
             */
            command.Parameters.AddWithValue("@Name", customer.Name);
            command.Parameters.AddWithValue("@Email", customer.Email);
            command.Parameters.AddWithValue("@CreatedAt", DateTime.Now);

            // Alternative explicit parameter declaration for stronger typing:
            /*
            command.Parameters.Add(new SqlParameter
            {
                ParameterName = "@Name",
                SqlDbType = SqlDbType.NVarChar,
                Size = 100,
                Value = customer.Name
            });
            */

            // 5. ExecuteScalar executes the command and retrieves the first column of the first row
            //    in the result set (in this case, the ID returned by SCOPE_IDENTITY()).
            var result = command.ExecuteScalar();

            // 6. Convert the result to int and return.
            //    SQL Server returns numeric(38,0) for SCOPE_IDENTITY(), which maps to decimal in .NET,
            //    so Convert.ToInt32 ensures correct type conversion.
            return Convert.ToInt32(result);
        }


        /*
 * GetAllCustomers
 * ================
 * Purpose:
 * ---------
 * Retrieves all customer records from the database and maps them into a list of 
 * strongly-typed `Customer` objects.
 * 
 * Process:
 * --------
 * 1. Creates a new SQL database connection using the configured connection string.
 * 2. Opens the connection synchronously.
 * 3. Defines and executes a `SELECT` statement to fetch customer data.
 * 4. Uses `SqlDataReader` to efficiently read data in a forward-only, read-only manner.
 * 5. Maps each record (row) to a `Customer` object and adds it to a list.
 * 
 * Returns:
 * --------
 * List<Customer> — A list containing all customers retrieved from the database.
 * If no records exist, an empty list is returned.
 * 
 * Notes:
 * ------
 * • `SqlDataReader` is a lightweight, high-performance cursor used for forward-only
 *   reading of result sets — ideal for large data queries.
 * • Each `Get*()` method (e.g., `GetInt32`, `GetString`) reads a specific column type.
 * • Using column indexes (0,1,2,3) is slightly faster than `GetOrdinal("ColumnName")`
 *   but less readable. Both approaches are valid.
 * • All resources (connection, command, reader) are automatically disposed by `using`.
 */
        public List<Customer> GetAllCustomers()
        {
            // 1. Create and open a new SQL connection
            using var connection = new SqlConnection(_connectionString);
            connection.Open(); // Synchronous call to establish database connection

            // 2. Define the SQL SELECT query
            //    Retrieves all customers and orders results by ID for consistency
            const string sql = "SELECT Id, Name, Email, CreatedAt FROM Customers ORDER BY Id";

            // 3. Create a SQL command object
            using var command = new SqlCommand(sql, connection);

            // 4. Initialize a list to hold Customer objects
            var customers = new List<Customer>();

            /*
             * ExecuteReader
             * ==============
             * Executes the SELECT statement and returns a SqlDataReader, which provides
             * fast, forward-only access to rows in the result set.
             * 
             * Behavior:
             * • Reader is read-only and forward-only — once you move past a row, you can’t go back.
             * • The connection remains open until the reader is closed.
             * • When used inside a `using` block, disposal of the reader will also close it automatically.
             */
            using var reader = command.ExecuteReader();

            /*
             * Mapping Each Row to a Customer Object
             * =====================================
             * Loop through the result set row-by-row.
             * For each row:
             *  - Extract column values using their zero-based indexes or names.
             *  - Map each value to the appropriate property of the Customer class.
             *  - Add the fully constructed object to the list.
             * 
             * NOTE: Ensure that data types in your SQL table match the expected CLR types:
             *   SQL INT        → C# int
             *   SQL NVARCHAR   → C# string
             *   SQL DATETIME2  → C# DateTime
             */
            while (reader.Read())
            {
                customers.Add(new Customer
                {
                    Id = reader.GetInt32(0),         // Column index 0: Id (INT)
                    Name = reader.GetString(1),      // Column index 1: Name (NVARCHAR)
                    Email = reader.GetString(2),     // Column index 2: Email (NVARCHAR)
                    CreatedAt = reader.GetDateTime(3)// Column index 3: CreatedAt (DATETIME2)
                });
            }

            // 5. Return the populated list of customers
            //    If no rows were returned, the list will simply be empty.
            return customers;
        }


        /*
 * UpdateCustomer
 * ===============
 * Purpose:
 * ---------
 * Updates an existing customer's record in the database with new information
 * (Name and Email) based on the customer’s unique identifier (Id).
 * 
 * Process:
 * --------
 * 1. Creates and opens a new SQL connection synchronously.
 * 2. Prepares an UPDATE statement using parameterized values to prevent SQL injection.
 * 3. Binds the parameters with explicit data types to ensure type safety and reliability.
 * 4. Executes the SQL command synchronously using ExecuteNonQuery().
 * 5. Evaluates the result — if one or more rows were affected, returns true (success).
 * 
 * Returns:
 * --------
 * bool — Returns `true` if at least one row was updated successfully,
 *         or `false` if no record with the given Id was found.
 * 
 * Notes:
 * ------
 * • Parameterized queries guarantee that user inputs are never directly injected into SQL text.
 * • `ExecuteNonQuery()` returns the number of rows affected — for UPDATE, this indicates how many
 *   records matched the WHERE condition and were modified.
 * • Using `using` blocks ensures that both connection and command objects are properly disposed,
 *   freeing up database resources immediately after execution.
 */
        public bool UpdateCustomer(Customer customer)
        {
            // 1. Create a SQL connection and open it synchronously.
            using var connection = new SqlConnection(_connectionString);
            connection.Open();

            /*
             * Parameter Safety and Performance
             * ================================
             * This section explains why parameterized SQL is a best practice:
             * 
             * 1. SQL Injection Prevention:
             *    - BAD: "UPDATE Customers SET Name = '" + name + "' WHERE Id = " + id;
             *    - GOOD: "UPDATE Customers SET Name = @Name WHERE Id = @Id;"
             *      Using parameters isolates data values from executable SQL text.
             * 
             * 2. Query Plan Reuse:
             *    - SQL Server caches query plans for parameterized statements.
             *    - This improves performance during repeated operations.
             * 
             * 3. Type Safety:
             *    - Each parameter enforces its expected SQL type (e.g., INT, NVARCHAR).
             *    - Prevents conversion and format errors at runtime.
             */
            const string sql = @"
        UPDATE Customers 
        SET Name = @Name, Email = @Email 
        WHERE Id = @Id;
    ";

            // 2. Create a command object that will execute the SQL query.
            using var command = new SqlCommand(sql, connection);

            /*
             * Parameter Definitions and Mappings
             * ==================================
             * @Id
             * ----
             * • SQL Type: INT
             * • Description: The primary key that uniquely identifies the customer record.
             * • Expected Source: customer.Id
             * 
             * @Name
             * ------
             * • SQL Type: NVARCHAR(100)
             * • Description: Updated customer name (supports Unicode text).
             * • Expected Source: customer.Name
             * 
             * @Email
             * -------
             * • SQL Type: NVARCHAR(200)
             * • Description: Updated customer email (supports special characters such as '@' and '.').
             * • Expected Source: customer.Email
             * 
             * Notes:
             * ------
             * AddWithValue() automatically infers parameter type from the provided CLR type.
             * For better performance and predictability in large systems, prefer using Add()
             * with an explicit SqlDbType and Size (see commented example below).
             */
            command.Parameters.AddWithValue("@Id", customer.Id);
            command.Parameters.AddWithValue("@Name", customer.Name);
            command.Parameters.AddWithValue("@Email", customer.Email);

            // Alternative explicit parameter creation for stronger type control:
            /*
            command.Parameters.Add(new SqlParameter
            {
                ParameterName = "@Name",
                SqlDbType = SqlDbType.NVarChar,
                Size = 100,
                Value = customer.Name
            });
            */

            // 3. ExecuteNonQuery executes SQL that does not return result sets.
            //    It returns the number of rows affected by the command.
            int affectedRows = command.ExecuteNonQuery();

            /*
             * Result Evaluation:
             * ==================
             * If affectedRows > 0:
             *    • At least one matching record was found and successfully updated.
             *    • The method returns true.
             * 
             * If affectedRows == 0:
             *    • No records matched the provided Id, or the new data is identical to existing data
             *      (in rare cases, SQL Server may optimize away the write).
             *    • The method returns false.
             */
            return affectedRows > 0;
        }


        /*
 * DeleteCustomer
 * ===============
 * Purpose:
 * ---------
 * Removes a specific customer record from the database using its unique identifier (Id).
 * 
 * Process:
 * --------
 * 1. Creates and opens a new SQL database connection synchronously.
 * 2. Prepares a DELETE statement with a parameterized WHERE condition (Id = @Id).
 * 3. Binds the parameter to ensure type safety and SQL injection prevention.
 * 4. Executes the command synchronously using ExecuteNonQuery().
 * 5. Evaluates the result — returns true if at least one row was deleted successfully.
 * 
 * Returns:
 * --------
 * bool — Returns `true` if a record was successfully deleted, 
 *         or `false` if no matching record was found.
 * 
 * Notes:
 * ------
 * • Parameterized queries protect against SQL injection, even for simple integer inputs.
 * • `ExecuteNonQuery()` returns the number of rows affected by the DELETE operation.
 * • If `0` rows are affected, it means no record with the provided Id exists.
 * • Using `using` blocks ensures all database resources are released properly.
 */
public bool DeleteCustomer(int id)
{
    // 1. Create and open a SQL connection synchronously.
    using var connection = new SqlConnection(_connectionString);
    connection.Open();

    /*
     * Parameterized Query Explanation
     * ===============================
     * Even though this command deletes by a simple numeric Id, parameters are still critical.
     * 
     * 1. Security:
     *    - Prevents SQL injection attacks.
     *    - Ensures that even if user input is tampered with, it is treated as a literal value,
     *      not executable SQL code.
     * 
     * 2. Performance:
     *    - Parameterized queries allow SQL Server to reuse cached execution plans.
     *      This improves speed when the same query structure runs multiple times
     *      with different parameter values.
     * 
     * 3. Code Consistency:
     *    - Enforces a standard practice across all CRUD methods.
     *    - Makes the codebase easier to maintain and reason about.
     * 
     * SQL Explanation:
     * ----------------
     * DELETE FROM Customers WHERE Id = @Id
     * - The WHERE clause ensures that only the record matching the provided Id will be removed.
     * - Without a WHERE clause, ALL records would be deleted — a common and critical mistake to avoid.
     */
    const string sql = "DELETE FROM Customers WHERE Id = @Id;";

    // 2. Create a SQL command using the query and connection.
    using var command = new SqlCommand(sql, connection);

    /*
     * Parameter Mapping
     * =================
     * @Id
     * ----
     * • SQL Type: INT
     * • Purpose: Represents the unique primary key of the record to be deleted.
     * • Source: Method parameter `id`.
     * 
     * AddWithValue automatically infers type based on the .NET type of the provided value (int).
     * For critical systems, consider specifying explicit SqlDbType (see alternative example below).
     */
    command.Parameters.AddWithValue("@Id", id);

    // Alternative with explicit type declaration for better control:
    /*
    command.Parameters.Add(new SqlParameter
    {
        ParameterName = "@Id",
        SqlDbType = SqlDbType.Int,
        Value = id
    });
    */

    // 3. ExecuteNonQuery executes the command and returns the number of rows affected.
    //    For DELETE, this number indicates how many records were removed.
    int affectedRows = command.ExecuteNonQuery();

    /*
     * Return Value Explanation
     * ========================
     * - If affectedRows > 0 → At least one record was successfully deleted.
     * - If affectedRows == 0 → No record matched the provided Id (nothing deleted).
     * 
     * Returning a boolean simplifies usage for the calling code:
     * Example:
     *    if (DeleteCustomer(5))
     *        Console.WriteLine("Customer deleted successfully!");
     *    else
     *        Console.WriteLine("Customer not found.");
     */
    return affectedRows > 0;
}

    }
}